%!TEX root = ../main.tex

\section{A MILP-based Solution}
\label{sec:sol}

In this section, we introduce an exhaustive solver-based approach to 
resolve the errors reflected in the complaint set.
This approach constructs a mixed-integer linear 
programming (MILP) problem~\cite{milp} by linearizing and parameterizing the 
corrupted query log over the tuples in the database. 
Briefly, an MILP is a linear program~\cite{} where only a subset of the undetermined variables
are required to be integers, while the rest are real valued.

Our general strategy is to model each query as a linear equation 
that computes the output tuple values from the inputs and to transform the
equation into a set of of linear constraints.   
In addition, the constant values in the queries are parameterized
into a set of undetermined variables, while the database state is encoded 
as constraints on the initial and final tuple values.
Finally, the undetermined variables are used to construct an objective function
that prefers value assignments that minimze both the amount that the queries change and
the number of non-complaint tuples that are affected. \alex{I was under the impression that we stick to using the non-complaint tuples as constraints.}

The rest of this section will first describe the process of linearizing a single query
and translating it into a set of constraints.  We then extend the process to the entire
query log and finally define the objective function.
Subsequent sections introduce optimizations that both
improve the speed and quality of the results, as well as harness the trade-off between the two. 


% \xlw{Essentially, 
% we convert the updating process of the query log into a set of 
% constraints, transform values in queries (in the query log)
% as undetermined variables, and 
% using these values to form the objective function. Thus, the problem of 
% deriving a log repair is converted into a mixed-integer linear 
% programming (MILP) optimization problem. }\\
% {\xlw{need to introduce MILP problems a little bit here, so readers know what undetermined
% variables are and why things need to be linearized}}






\subsection{Encoding a Single Query}%Linearizing \& Parameterizing Single Query}
\label{sec:linearize}

\if{0}
  We model a query $q_i$ as a conditional function $f_{q_i}(t)$ that takes as input a tuple $t$
  and returns its next state $t'$.  $f_{q_i}$ is applied to each 
  tuple $t \in \mathcal{D}_{i-1} \cup \{\bcancel{t}\}$ in the input relation along with a special
  non-existant tuple $\bcancel{t}$. \ewu{maybe fold this into the data model.}
  By treating the query as a function, we are able to encode its effects into a set
  of linear inequality constraints.  We call this process the linearization and 
  parameterization of a query.

  \begin{definition} [Conditional Function]
  \label{def:cond}
    The conditional function for query $q$ is:
    \[
      f_{q_i}(t)= 
      \begin{cases}
      f_{q_i.\mu} (t) ,& \text{if } f_{q_i.\sigma} (t)\\
      t,              & \text{otherwise}
      \end{cases}
  \]
  where the \textit{update function} $f_{q_i.\mu}$ models a set of \textit{update equation(s)};
  and the \textit{condition function} $f_{q_i.\sigma}$ models a set of \textit{logical expression(s)} in 
  disjunctive or conjunctive form.
  \end{definition} 


  % We linearize and parameterize a query $q$ by considering its effects on the 
  % targeted table $R(A_1, ..., A_m)$: we treat the query $q$ as a 
  % conditional function over each tuple $t\in R$ and convert the effects of $q$ 
  % over $t$ into a set of linear inequality constraints. 
  % \subsubsection{Query as a Conditional Function}
  % The effect of query $q$ over a tuple $t$ can be expressed in a conditional
  % function $f_q(t)$ as the following:

  Conditional functions can describe the common classes of update queries:
  \begin{enumerate}
  \item \texttt{UPDATE}: $f_{q_i.\mu}(t)$, $f_{q_i.\sigma}(t)$ model the \texttt{SET}
        and \texttt{WHERE} clauses.  For example, $f_{q_i.\mu}(<t.a, t.b>) = <t.a + 1, 2>$ and
        $f_{q_i.\sigma}(t) = (t.a > 20)$ corresponds to the query 
        \texttt{UPDATE D SET a = a + 1, b = 2 WHERE a > 20}.

  \item \texttt{INSERT}: $f_{q_i.\mu}(t)$ returns the inserted tuple, while 
        $f_{q_i.\sigma}(t) = (t = \bcancel{t})$ evaluates to true when it is executed over
        the special nonexistant tuple.
        %is a boolean variable reflects 
        %the existence of tuple $t$; $\vee_{t\in R} f_{q.\sigma}(t)$ represents 
        %the existence of this insert query.  

  \item \texttt{DELETE}: $f_{q_i.\mu}(t) = \bcancel{t}$ returns a nonexistant tuple whenever
        the predicate encoded in $f_{q_i.\sigma}(t)$ evaluates to true.
        For example, the query \texttt{DELETE FROM T WHERE a < 20} represents 
        $f_{q_i.\sigma}(t) = (t.a < 20)$.
        
        % the deleted values for 
        % each attribute and $f_{q.\sigma}(t)$ reflects the expressions in where clause 
        % (similar to $f_{q.\sigma}(t)$ in \texttt{UPDATE} query).
  \end{enumerate}

  Finally, we parameterize $q_i$ by replacing all numeric constants in the
  conditional function with undetermined variables.   Consider the conditional
  function for \texttt{UPDATE} above: the constants $1$, $2$ in $f_{q_i.\mu}$
  as well as $20$ in $f_{q_i.\sigma}$ will be transformed into undetermined
  variables \texttt{v1, v2, v3} that are solved by the MILP solver.

  % We parameterize query $q$ by replacing all numeric values in the above conditional 
  % function into undetermined variables (Example~\ref{ex:parameterize}).
  % \begin{example}\label{ex:parameterize}
  % Consider a \texttt{UPDATE} query $q$:
  % \texttt{UPDATE R SET A$_1$ = 3 WHERE A$_2$ $\leq$ 10},
  % the conditional function of this query is: 
  % \[
  %     f_q(t)= 
  % \begin{cases}
  %     f_{q.\mu}(t) = \{t.A_1 = 3\} ,& \text{if } f_{q.\sigma}(t) = \wedge\{t.A_2 \leq 10\}\\
  %     t,              & \text{otherwise}
  % \end{cases}
  % \]
  % The numeric variables in query $q$ including \texttt{3} in $f_{q.\mu}(t)$ and \texttt{10}
  % in $f_{q.\sigma}(t)$. Thus, we parameterize query $q$ by replacing the value \texttt{3, 10}
  % by two undetermined variables \texttt{var1, var2}. 
  % \end{example} 
\fi



% \subsubsection{Constructing Linear Inequality Constraints}

MILP problems require that the constraints are expressed as a set of linear
(in)equality constraints, thus our task is to linearize the parameterized
conditional function.   We will individually describe this linearization process 
to represent the value of a single attribute $A_j$ and a single tuple $t$ for 
\texttt{UPDATE}, \texttt{INSERT}, and \texttt{DELETE} queries; 
extending the process to the rest of the attributes is a straighforward exercise.
% Now that we have modeled $q_i$ as a parameterized conditional function, 
% we must linearize $f_{q_i}$ into a set of linear (in)equality constraints
% for the MILP problem.



\stitle{\textbf{UPDATE:} }
Recall from Section~\ref{sec:models} that query $q_i$ can be modeled as
the combination of a modifying function $\mu_{q_i}(t)$ and conditional function $\sigma_{q_i}(t)$.
We can re-express the value of attribute $A_j$ in the updated tuple $t'$ as the following equation:
{\scriptsize
\begin{eqnarray}
\label{eq:linearization}
t'.A_j = x\otimes \mu_{q_i}(t).A_j + (1-x)\otimes t.A_j 
\end{eqnarray} 
}


\noindent Where the binary variable $x$ is introduced to represent the output of 
the conditional function:
{\scriptsize
\begin{eqnarray}
\label{eq:x}
x = \sigma_{q_i}(t)
\end{eqnarray}
}
We then introduce two variables $u.A_j$ and $v.A_j$ to represent 
the respective components in Equation~\ref{eq:linearization}, where
$M$ representes the upper bound of $t.A_j$'s domain:
{\scriptsize 
\begin{eqnarray}
\label{eq:uv}
u.A_j &\leq & \mu_{q_i}(t).A_j \nonumber\\
u.A_j &\leq & xM \nonumber\\ 
u.A_j &\geq & \mu_{q_i}(t).A_j - (1-x)M \nonumber \\\nonumber \\
v.A_j &\leq & t.A_j \nonumber\\
v.A_j &\leq & (1-x)M \nonumber\\
v.A_j &\geq & t.A_j - xM
\end{eqnarray}
}
The first set of conditions forces $u.A_j = \mu_{q_i}(t).A_j$ if $x=1$, and $0$ otherwise.  
The second set forces $v.A_j = t.A_j$ if $x=0$, and $0$ otherwise.  
Now, Equation~\ref{eq:linearization} is simply a linear equation:
{\scriptsize\begin{eqnarray}
\label{eq:tnew}
t.A_j' = u.A_j + v.A_j
\end{eqnarray}}



\stitle{\textbf{INSERT:}}
An insert query adds a new tuple $t_{new}$ to the database.  If the query were 
corrupted, then the inserted values may need to be repaired.  Thus, we allocate
an undetermined variable for each of the inserted tuple's attributes:
{\scriptsize
\begin{eqnarray}
\label{eq:insert}
t'.A_j = x \otimes t_{new}.A_j + (1-x) \otimes v.A_j 
\end{eqnarray}
}
\noindent Where $x$ is an undetermined binary variable that represents whether
the query is incorrect.  If it is, then it takes the value of an undetermined real 
variable $v.A_j$.


\stitle{\textbf{DELETE:}}
A delete query removes a set of tuples from the database.  
Since the MILP problem doesn't have a way to express a non-existant value, 
we encode a deleted tuple by setting its attributes to a value
outside of the attribute domain $M^+$.  In this way, subsequent conditional functions
on the attribute will return false, so it will not have an effect on subsequent queries encoded
in the MILP problem:
{\scriptsize
\begin{eqnarray}
\label{eq:delete}
t'.A_j &=& x \otimes M^+ + (1-x) \otimes t.A_j \nonumber \\
x &=& \sigma_{q_i}(t)
\end{eqnarray}
}


\stitle{\textbf{Putting it All Together:}}

% )(\ref{eq:uv})(\ref{eq:tnew})(\ref{eq:insert})(
The above constraints (\ref{eq:x}--\ref{eq:delete})
form the main structure of MILP subproblem for a single attribute $A_j$ of a single tuple $t$.
In this incomplete form, all of the variables including the binary variables $x$,
the real-valued attribute values (e.g., $u.A_j$),
and the real-valued constants in $\mu_{q_i}$ and $\sigma_{q_i}$ are all undetermined
and need to be assigned values by a MILP solver.  
To linearize $q_i$, we can simply apply the same procedure for each attribute in the 
query and every tuple in the database.
We describe the above linearization process as the function 
$Linearize(q, t)$, which takes a query $q$ and tuple $t$ as input.

The final step is to assign concrete values to the starting and ending attribute values 
$t.A_j$ and $t'.A_j$ based on the starting database state $D_{i-1}$ and the ending database 
state that has been transformed by $\mathcal{C}$, $D'_i$.
In this way, only the query parameters and the binary $x$ variables are undetermined;
a solution to the MILP formulation will assign values to those undetermined variables
such that the resulting query fixes the complaints correctly.

The next subsection will describe how to extend the above encoding procedure to the 
entire query log, and how to incorporate an objective function that encourages solutions
that minimize the amount of changes to the query log.  







\subsection{Encoding and Repairing the Query Log}
\label{sec:milp}

We are now ready to describe the procedure (Algorithm~\ref{alg:basic}) to encode 
the full query log into a MILP problem, and solve the MILP problem to derive $\mathcal{Q}^*$.
The algorithm takes as input the query log $\mathcal{Q}$, 
the initial and final (dirty) database states 
$\mathcal{D}_{0, n}$, and the complaint set $\mathcal{C}$, and outputs a fixed query 
log $\mathcal{Q}^*$.  

We first call \textit{Linearize} on each tuple in $\mathcal{D}_0$ and each query in $\mathcal{Q}$, 
and add the result to a set of constraints \textit{milp\_cons}.
Similar to the single-query procedure, \textit{AssignVals} additionally 
adds constraints to fix the values of the inputs to $q_0$ and 
the outputs of $q_n$ to their respective values in
$\mathcal{D}_0$ and $\mathcal{C}(\mathcal{D}_n)$.
Next, we add constraints to take into account the fact that the output of 
query $q_i$ is the input of $q_{i+1}$ (\textit{ConnectQueries}).
This function simply equates $t'$ from the linearized result for $q_i$ to the $t$ input 
for the linearized result of $q_{i+1}$.

Finally, we use the undetermined variables in \textit{milp\_cons}, along with $\mathcal{Q}$,
to encode the distance function $d$ described in Section~\ref{def:obj} 
into the MILP objective function, and submit it to a MILP solver.
\textit{ConvertQLog} replaces the constants in the query log with the 
assigned values for the undetermined variables in the solution, and constructs
the fixed query log $\mathcal{Q}^*$.
\ewu{explicitly mention each function in algorithm.}



% Using the linearization method in Section~\ref{sec:linearize}, we can further
% linearize the entire query log by converting every tuples in the table $R$. 
% During the linearization, we further parameterize each
% query in the query log $\mathcal{Q}$ in order by derive the log repair. 
% The linearized and parameterized query log
% should start from and end at clean database states.
% To achieve this, we add constraints by assigning the true initial and end database 
% states' values (based on complaints) to the corresponding variables. 
% Following the above steps (Algorithm~\ref{alg:basic}), we convert the 
% query log into a collection of constraints with newly introduced variables. 
% Some of these variables are introduced to linearize the query log 
% and the rest usually represent the numeric values in the query log
% during the paramerization process. 
% The latter set of variables often involved in the objective function 
% according to the pre-defined distance function $d$ 
% (as described in Definition~\ref{def:problem}). 


\begin{algorithm}[htbp]
\caption{$QueryFix_{exh}$ based on MILP formulation.}
\label{alg:basic}
\scriptsize
\begin{algorithmic}
\REQUIRE {$\mathcal{Q}, D_0, D_n, \mathcal{C}$}
%\ENSURE {$\mathcal{Q^*}$}
\STATE $milp\_cons \leftarrow \emptyset$
\FOR {each $t$ in $R$}
\FOR {each $q$ in $\mathcal{Q}$}
\STATE $milp\_cons \leftarrow milp\_cons \cup Linearize(q, t)$
\ENDFOR
\STATE $milp\_cons \leftarrow milp\_cons \cup AssignVals(D_0.t, D_n.t, \mathcal{C})$
\FOR {each $i$ in $\{0,\ldots,N-1\}$}
\STATE $milp\_cons \leftarrow milp\_cons \cup ConnectQueries(q_i, q_{i+1})$
\ENDFOR
\ENDFOR 
\STATE $milp\_obj \leftarrow EncodeObjective(milp\_cons, \mathcal{Q})$
\STATE $solved\_vals \leftarrow MILPSolver(milp\_cons, milp\_obj)$
\STATE $\mathcal{Q}^* \leftarrow ConvertQLog(Q, solved\_vals)$
\STATE Return $\mathcal{Q}^*$
\end{algorithmic}
\end{algorithm}

% By constructing linear (in)equality constraints and
% defining a objective function, we convert the problem into
%  a mixed-integer linear programming (MILP) problem that can be 
%  solved by MILP solvers. By solving this MILP problem, we collect the
% corrections for the parameterized variables and form the log repair. 

% describe how to linearize the whole querylog with provided
% database states info. 

















